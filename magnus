#!/usr/bin/env python3

import pathlib as pl, functools as ft
import os, sys, codecs, json, signal, warnings

import gi
gi.require_version('Gtk', '3.0')
gi.require_version('Keybinder', '3.0')
from gi.repository import Gtk, Gdk, GLib, GdkPixbuf, Gio

try: from gi.repository import Keybinder # libkeybinder3
except ImportError: Keybinder = None

try: import setproctitle # pip3 install --user proctitle
except ImportError: setproctitle = None

# Be sure to compile it with gcc first
import magnus_pixbuf_proc as mpp


p_err = ft.partial(print, file=sys.stderr, flush=True)

class Magnus:

	def __init__(self, refresh_interval):
		self.zoomlevel = 2
		self.app = Gtk.Application.new('org.jncDdHBql.K9LwUiqXJ.magnus', 0)
		self.decorations_height = 0
		self.decorations_width = 0
		self.last_x = -1
		self.last_y = -1
		self.refresh_interval = refresh_interval
		self.app.connect('activate', self.app_init)

	def app_init(self, app):
		GLib.set_application_name('Magnus')

		# the window
		self.w = Gtk.ApplicationWindow.new(self.app)
		self.w.set_size_request(300, 300)
		self.w.set_title('Magnus')
		self.w.connect('destroy', lambda a: self.app.quit())
		self.w.connect('configure-event', self.window_configure)
		self.w.connect('window-state-event', self.window_configure)
		self.w.connect('size-allocate', self.read_window_decorations_size)
		devman = self.w.get_screen().get_display().get_device_manager()
		self.pointer = devman.get_client_pointer()

		# the headerbar
		head = Gtk.HeaderBar()
		head.set_show_close_button(True)
		head.props.title = 'Magnus'
		self.w.set_titlebar(head)

		# the zoom chooser
		zoom = Gtk.ComboBoxText.new()
		self.zoom = zoom
		for i in range(2, 6):
			zoom.append(str(i), '{}Ã—'.format(i))
		zoom.set_active(0)
		zoom.connect('changed', self.set_zoom)
		head.pack_end(zoom)

		# whole window is cairo drawing surface
		self.img = None
		self.da = Gtk.DrawingArea()
		self.da.set_hexpand(True)
		self.da.set_vexpand(True)
		self.da.connect('draw', self.draw)
		self.w.add(self.da)

		# bind the zoom keyboard shortcuts
		if Keybinder:
			Keybinder.init()
			if Keybinder.supported():
				Keybinder.bind('<Alt><Super>plus', self.zoom_in, zoom)
				Keybinder.bind('<Alt><Super>equal', self.zoom_in, zoom)
				Keybinder.bind('<Alt><Super>minus', self.zoom_out, zoom)

		# updates
		self.width = 0
		self.height = 0
		self.window_x = 0
		self.window_y = 0
		GLib.timeout_add(250, self.read_window_size)
		GLib.timeout_add(self.refresh_interval, self.update)

		# resize and present window
		self.w.show_all()


	def zoom_out(self, keypress, zoom):
		current_index = zoom.get_active()
		if current_index == 0:
			return
		zoom.set_active(current_index - 1)
		self.set_zoom(zoom)

	def zoom_in(self, keypress, zoom):
		current_index = zoom.get_active()
		size = zoom.get_model().iter_n_children(None)
		if current_index == size - 1:
			return
		zoom.set_active(current_index + 1)
		self.set_zoom(zoom)

	def read_window_decorations_size(self, win, alloc):
		sz = self.w.get_size()
		self.decorations_width = alloc.width - sz.width
		self.decorations_height = alloc.height - sz.height

	def set_zoom(self, zoom):
		self.zoomlevel = int(zoom.get_active_text()[0])
		self.update(force_refresh=True)
		self.serialise()

	def read_window_size(self, *args):
		loc = self.w.get_size()
		self.width = loc.width
		self.height = loc.height

	def window_configure(self, window, ev):
		self.read_window_size()
		if ev.type != Gdk.EventType.CONFIGURE: return
		self.window_x = ev.x
		self.window_y = ev.y


	@ft.lru_cache()
	def makesquares(self,
			overall_width, overall_height, square_size, value_on, value_off):
		on_sq = list(value_on) * square_size
		off_sq = list(value_off) * square_size
		on_row = []
		off_row = []
		while len(on_row) < overall_width * len(value_on):
			on_row += on_sq
			on_row += off_sq
			off_row += off_sq
			off_row += on_sq
		on_row = on_row[:overall_width * len(value_on)]
		off_row = off_row[:overall_width * len(value_on)]

		on_sq_row = on_row * square_size
		off_sq_row = off_row * square_size

		overall = []
		count = 0
		while len(overall) < overall_width * overall_height * len(value_on):
			overall += on_sq_row
			overall += off_sq_row
			count += 2
		overall = overall[:overall_width * overall_height * len(value_on)]
		return overall

	@ft.lru_cache()
	def get_white_pixbuf(self, width, height):
		square_size = 16
		light = (153, 153, 153, 255)
		dark = (102, 102, 102, 255)
		whole = self.makesquares(width, height, square_size, light, dark)
		arr = GLib.Bytes.new(whole)
		return GdkPixbuf.Pixbuf.new_from_bytes(
			arr, GdkPixbuf.Colorspace.RGB, True, 8,
			width, height, width * len(light))


	def update(self, force_refresh=False):
		display = Gdk.Display.get_default()
		(screen, x, y, modifier) = display.get_pointer()
		if x == self.last_x and y == self.last_y:
			# bail if nothing would be different
			if not force_refresh: return True
		self.last_x = x
		self.last_y = y
		if (x > self.window_x and
				x <= (self.window_x + self.width + self.decorations_width) and
				y > self.window_y and
				y <= (self.window_y + self.height + self.decorations_height)):
			# pointer is over our window, so make it an empty pixbuf
			self.img = Gdk.cairo_surface_create_from_pixbuf(
				self.get_white_pixbuf(self.width, self.height), 0, None )
		else:
			root = Gdk.get_default_root_window()
			scaled_width = self.width // self.zoomlevel
			scaled_height = self.height // self.zoomlevel
			scaled_xoff = scaled_width // 2
			scaled_yoff = scaled_height // 2
			screenshot = Gdk.pixbuf_get_from_window(
				root, x - scaled_xoff,
				y - scaled_yoff, scaled_width, scaled_height)
			if screenshot:
				screenshot = self.tweak_colors(screenshot)
				screenshot = screenshot.scale_simple(
					self.width, self.height, GdkPixbuf.InterpType.NEAREST )
				self.img = Gdk.cairo_surface_create_from_pixbuf(screenshot, 0, None)
		self.da.queue_draw()
		return True

	def tweak_colors(self, screenshot):
		cs = screenshot.get_property('colorspace')
		if cs != GdkPixbuf.Colorspace.RGB:
			warnings.warn(f'Disabling color tweaks - unsupported colorspace: {cs}')
		else:
			w, h = screenshot.get_width(), screenshot.get_height()
			rs, buff = screenshot.get_rowstride(), screenshot.get_pixels()
			mpp.apply_curves(w, h, buff)
			screenshot = GdkPixbuf.Pixbuf.new_from_data(buff, cs, False, 8, w, h, rs)
		return screenshot

	def draw(self, da, ctx):
		w = da.get_allocation()
		w, h = w.width, w.height
		Gtk.render_background(da.get_style_context(), ctx, 0, 0, w, h)
		if not self.img: return
		ctx.set_source_surface(self.img, 0, 0)
		ctx.paint()


def main(args=None):
	import argparse
	parser = argparse.ArgumentParser(
		description='Simple screen magnifier tool with color tweaks.')
	parser.add_argument('-r', '--refresh-interval',
		type=int, metavar='ms', default=250,
		help='Refresh interval in milliseconds (lower is faster). Default: %(default)s')
	opts = parser.parse_args(sys.argv[1:] if args is None else args)
	Magnus(opts.refresh_interval).app.run()

if __name__ == '__main__':
	warnings.filterwarnings('ignore', category=DeprecationWarning)
	signal.signal(signal.SIGINT, signal.SIG_DFL) # allow gtk to handle this (die quietly)
	if setproctitle: setproctitle.setproctitle('magnus')
	sys.exit(main())
